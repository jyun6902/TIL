비트연산
=============
1)비트 연산자 (1<< n)
-------------
> << 사용하여 정수값을 왼쪽으로 시프트 : 곱한 결과

사용하는 경우
1. 2^n의 값을 가짐, 원소가 n개일 경우의 모든 부분집합의 수를 의미
2. Power set(모든 부분 집합)
 - 공집합과 자기 자신을 포함은 모든 부분 집합
 - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분 집합의 수 계산 가능

3. i&(1<<j)

j|7 6 5 4 3 2 1 0
-|---------------
i|0 1 0 0 1 0 1 0

* 2^6 + 2^3 + 2^1
4. 특정 위치의 비트 값이 1인지 0인지 판별하고 싶을 때 사용

5. 계산 결과 : i의 j번째 비트가 1인지 아닌지 의미

* 1<<6 -> 1
* i&(1<<6) ->1
* 0일 경우 포함X

 
2)비트마스크 연산을 이용해 집합을 조작하는 예제 : 피자집
-------------
> 피자에 0~19번까지 번호를 갖는 스 무가지 토핑을 주문 시 넣기/넣지 않기 선택 할 수 있다.
1. 꽉 찬 집합 (스무 개의 토핑을 모두 포함하는 집합) -> 모든 비트가 켜진 숫자
<pre><code>// 1<<20은 이진수로 1 뒤에 20개의 0이 있는 정수이다
// 여기서 1을 빼면 20개의 비트가 모두 켜진 수를 얻는다
int fullPizza = (1<<20) -1;</code></pre>

2. 집합에 원소 추가 (해당 비트를 켠다) -> 가령 페퍼로니 번호가 p(0<p<20)일 때 다음처럼 toppings 집합에 페퍼로니를 추가할 수 있다.
<pre><code>/*1을 왼쪽으로 p비트 시프트하면 p번 비트만 켜진 정수가 되므로 
이 값과 toppings를 비트별 OR하면 해당 비트는 반드시 켜지게 된다.
이미 페퍼로니가 들어있어서 1일 경우에는 아무 변동이 없는 셈이다. 
*/
toppings |= (1 << p );</code></pre>

3. 원소의 포함 여부 확인
<pre><code>if(toppings & (1 << p) )cout << "found" << endl;
/* & 연산 결과 값이 0 또는 (1 << p ) 이다. 
습관적으로 1혹은 true가 반환된다고 생각하면 아래와 같은 코드를 작성하게 된다. */
if((topping & (1<< p)) == 1)
cout << "found "<< endl;//하지만 1 << p이 결과값일 경우 p가 0이 아닌이상 1이 아니다. 즉 작동하지 않게 된다.</code></pre>

4. 원소의 삭제
<pre><code>toppings &= ~(1 << p);
/* ~ (1 << p) 은 Not연산을 하므로 해당 비트만 꺼지고 다 켜진 수가 된다.
 이 수와 &연산을 하므로 나머지 비트는 유지되고 항상 p번 비트는 꺼지게 된다.*/</code></pre>

5. 원소의 토글 (켜져있으면 끄고 꺼져있으면 켜고) : p번 토핑이 들어가 있으면 빼고 빠져있으면 넣는다
<pre><code>toppings ^= (1 << p);</code></pre>

6. 두 집합에 대해 연산하기 : 원소가 아니라 집합 간에도 마찬가지이다.
<pre><code>int added = (a | b); //a와 b의 합집합
int intersection = (a & b); ///a와 b의 교집합
int removed = (a & ~b); //a에서 b를 뺀 차집합
int toggled = (a ^ b); //a와 b중에 하나에만 포함된 원소들의 집합</code></pre>

3)비트 연산 예제
----------------
예제1) 특정 위치의 비트값을 확인하는 수식
<pre><code>
void BitPrint(char i)
{
	for (int j = 7; j >= 0; j--)
		putchar((i&(1 << j)) ? '1' : '0')//printf("%d", (i>>j) &1);
}

void main(void)
{
	char i;
	for (i = -5; i < 6; i++)
	{
		printf("%3d= ", i); //십진수 출력
		BitPrint(i); //이진수 출력
		putchar('\n');
	}
}
</code></pre>

 i |BitPrint(i) 
---|---------
-5 | 11111011
-4 | 11111100
-3 | 11111101
-2 | 11111110
-1 | 11111111
 0 | 00000000
 1 | 00000001
 2 | 00000010
 3 | 00000011
 4 | 00000100
 5 | 00000101

예제2) 부분 집합 만드는 식(조합)
<pre><code>
void make_combination(int N)
{
	for (int i = 0; i < 11; i++)
		v[i].clear();

	for (int num = 0; num < (1 << N); num++)
	{
		vector <int> d;

		for (int i = 0; i < N; i++)
		{
			if (num&(1 << i))
				d.push_back(i);
		}
		v[d.size()].push_back(d);
	}
}
</code></pre>

## 주의 사항
- C++에서는 &,|,^ 등의 비트 연산자의 우선순위는 ==혹은 != 등의 비교연산자 보다 낮다.
- int c = (6&4 == 4); 의 경우 4==4가 먼저 계산된다. 헷갈리지 않게 항상 괄호를 쓰자.

## 관련링크
- <https://www.swexpertacademy.com/main/learn/course/lectureVideoPlayer.do>
- <http://mrl.kr/bitmask/>
