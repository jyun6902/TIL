비트연산
=============
1)비트 연산자
-------------
# 1<<n
> << 사용하여 정수값을 왼쪽으로 시프트 : 곱한 결과
##사용하는 경우
1. 2^n의 값을 가짐
2. 원소가 n개일 경우의 모든 부분집합의 수를 의미
3. Power set(모든 부분 집합)
 - 공집합과 자기 자신을 포함은 모든 부분 집합
 - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분 집합의수 계산 가능

i&(1<<j)
 7 6 5 4 3 2 1 0
i0 1 0 0 1 0 1 0  2^6 + 2^3 + 2^1
-특정 위치의 비트 값이 1인지 0인지 판별하고 싶을 때 사용
-계산 결과 : i의 j번째 비트가 1인지 아닌지 의미

1<<6 -> 1
i&(1<<6) ->1


 
2)비트 연산 예제
----------------
예제1) 특정 위치의 비트값을 확인하는 수식
<pre><code>
void BitPrint(char i)
{
	for (int j = 7; j >= 0; j--)
		putchar((i&(1 << j)) ? '1' : '0')//printf("%d", (i>>j) &1);
}

void main(void)
{
	char i;
	for (i = -5; i < 6; i++)
	{
		printf("%3d= ", i); //십진수 출력
		BitPrint(i); //이진수 출력
		putchar('\n');
	}
}
</code></pre>

예제2) 부분 집합 만드는 식(조합)
<pre><code>
void make_combination(int N)
{
	for (int i = 0; i < 11; i++)
		v[i].clear();

	for (int num = 0; num < (1 << N); num++)
	{
		vector <int> d;

		for (int i = 0; i < N; i++)
		{
			if (num&(1 << i))
				d.push_back(i);
		}
		v[d.size()].push_back(d);
	}
}
</code></pre>

관련링크 : <https://www.swexpertacademy.com/main/learn/course/lectureVideoPlayer.do>
